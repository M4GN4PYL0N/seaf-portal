# Ролевая модель SEAF.ArchTool

Ниже опишем принцип создания ролевой модели для SEAF.ArchTool

Ролевая модель построена на регулярных выражениях которые фильтруют озеро данных по вхождениям ключей.

**Особенности фильтрации озера данных**:
* **Рекурсивность**: Функция рекурсивно обрабатывает все вложенные объекты, применяя те же правила фильтрации
* **Сохранение структуры**:
  * Для объектов сохраняется структура ключ-значение
  * Для массивов сохраняется последовательность элементов
* **Иммутабельность**: Создается новый объект, исходный объект не изменяется
* **Оптимизация**:
  * Примитивы и массивы обрабатываются без рекурсии
  * Проверки выполняются только для объектов
* **Гибкость**:
  * Можно комбинировать регулярные выражения и исключения
  * Фильтрация работает на любом уровне вложенности

Запись фильтруется если:
* Значение не является объектом (примитив)
* Значение является массивом
* Ключ находится в списке исключений
* Ключ соответствует хотя бы одному регулярному выражению

```yaml
object:
  property_1: AnyData    # Попадет в озеро независимо от фильтров, потому что является примитивом
  property_2:            # Попадет в озеро только если будет регулярное выражение пропускающее такую запись
    subproperty_1: ZZZ
    subproperty_2: WWW
  property_3:            # Попадет в озеро минуя фильтры потому что содержит массив
    - subprop_1: 1
    - subprop_2: 2
```

Включение ролевой модели выполняется переменной:
```properties
VUE_APP_DOCHUB_ROLES_MODEL=(y/n) - включена/выключена
```
Важно, что ролевая модель работает только в режиме Backend:
```properties
VUE_APP_DOCHUB_MODE=backend
```
При запуске docker-compose из данного репозитория переменную задавать не требуется!

При включении ролевой модели обязательно должна быть настроена аутентификация с помощью OIDC провайдера, выполняется в параметрах:
```properties
VUE_APP_DOCHUB_AUTHORITY_SERVER=(url провайдера учетных записей)
VUE_APP_DOCHUB_AUTHORITY_CLIENT_ID=(идентифкатор клиента)
VUE_APP_DOCHUB_AUTH_PUBLIC_KEY=-----BEGIN PUBLIC KEY-----.......-----END PUBLIC KEY----- - (Token Signing Key)
```

Непосредственно роли задаются в конфигурационных файлах roles.yaml и default.yaml (должен находиться в той же директории что и roles.yaml).
Файл с ролями подключается следующей переменной:
```properties
VUE_APP_DOCHUB_ROLES=file:///roles/roles.yaml - задается путь относительно папки public
```
В файле **roles.yaml** задаются регулярные выражения для фильтрации ключей которые разрешены для роли, в секции default перечислены ключи доступные пользователю не прошедшему аутентификацию. **Роль не может быть пустой, обязательно оставляйте в роли какое-то регулярное выражение!**
Ниже пример файла с ролями:
```yaml
roles:
    users:
      - '^entities$'
      - '^docs$'
      - '^presentations$'
      - '^(location|title|description|config|root_menu|source|schema|type|patternProperties|properties|icon|subjects|template|anyOf|pattern|"$ref")$'
      - '^menu$'
      - '^dochub.*$'
    default:
      - '^docs$'
      - '^dochub\.welcome$'
```
Где,
**default** - полномочия доступные пользователю не прошедшему аутентификацию
**users** - полномочия пользователя с ролью **users**

В файле **default.yaml** перечислен список регулярных выражений и исключений, которые **будут добавляться к каждой роли из файла roles.yaml**!
```yaml
roles:
      - '^anything$'
exclude:
      - 'patternProperties'
```

Рассмотрим на примере:
```yaml
entities:
  docs:
    title: Документы
    config:
      root_menu: Документы
    menu: >
      (
        код вашего меню
      )
    presentations:
      card:
        type: markdown
          .....
    schema:
      ....

docs: 
  dochub.welcome:
    title: Приветственный документ
    location: Документ
    type: markdown
    template: doc.md
```
Для роли **users**, с учетом приведенного выше примера, в озере данных после применения ролевой модели останется весь манифест, а для роли **default** манифест сократится до:
```yaml
entities:
  docs:
    title: Документы
    menu: 
      (
        код вашего меню
      )
docs: 
  dochub.welcome:
    title: Приветственный документ
    type: markdown
    template: doc.md
```
Для того чтобы эффективно работать с ролевой моделью необходимо понимать общую концепцию работы в инструменте, аспекты построения меню и представлений.

Давайте разберем нембольшой пример для погружения в детали с меню и презентациями:
```yaml
# Это описание сущности, то есть метамодель
entities:
  systems:                          # Здесь описывается некая сущность systems с ее схемой, свойствами, меню и презентациями
    title: Документы
    menu: >                         # Здесь содержится код который создает разделы в меню для данной сущности
      (
        код вашего меню
      )
    presentations:                  # Здесь содержатся представления, то куда ведут ссылки из меню
      card:
        type: markdown
          .....
    schema:
      ....

# Это описание объектов сущности
systems:                            
  system.one:
    title: Система первая
    description: Просто какая-то система
```

Если мы хотим роли default показывать меню и представления сущностей systems, а также сами объекты сущности systems, то необходимо перечислить следующие регулярные выражения для роли default:
```yaml
roles:
    users:
      .....                               # Здесь какие-то роли
    default:
      - '^entities$'                      # Разрешаем читать объект entites
      - '^systems$'                       # Разрешаем читать объект systems как внутри entities так и объект systems содержащий объекты этого типа
      - '^system\..*$'                    # Разрешаем читать объекты внутри systems (system.one.....)
      - '^presentations$'                 # Читаем раздел презентации 
      - '^cards$'                         # Читаем представление cards
```

Как упростить себе задачу?
Можно выбрать все фильтруемые объекты списком и собрать в excel регулярные выражения...

#### Действия по шагам

1. Вывести список всех фильтруемых объектов:
```jsonata
$getFilterable := function($obj){(
    $obj ~> $each(function($v, $k){$type($v) = "object" ? $append($k, $getFilterable($v))});
)};
$dataset := $mergedeep($ ~> $each(function($v, $k){$k in ["entities", "datasets", "functions", "$package", "rules", "kadzo", "companies", "sber"] ? {"metamodel":{$k:$v}} : {"data":{$k:$v}}}));
{
    "Ключи данных":$getFilterable($dataset.data).* ~> $distinct()^($),
    "Ключи метамодели": $getFilterable($dataset.metamodel).* ~> $distinct()^($)
};
```
* Список ключей метамодели использовать для управления доступом к представлениям и меню.
* Список ключей данных использовать для управления доступом к архитектурным данным.

2. Просуммировать в регулярные выражения названия объектов архитектурного озера, например строки
*    "kadzo.metamodel.v2023.data_objects"
*    "kadzo.metamodel.v2023.data_objects.general"
*    "kadzo.metamodel.v2023.data_objects.parent"
*    "kadzo.metamodel.v2023.data_objects.systems"
*    "kadzo.metamodel.v2023.domain"
*    "kadzo.metamodel.v2023.domain.foreign"

Легко превращаются в следующее регулярное выражение
```regexp
^kadzo\.metamodel\.v2023\..*$
```

3. Результат положить в роль